import os
import re
import json
import time
import random
import requests
import pytz
import pandas as pd
from datetime import datetime
from typing import List, Tuple
from bs4 import BeautifulSoup

# We will integrate a second weather source (OpenWeather) for more
# descriptive alerts about today's conditions.  The following
# constants and helper function are adapted from the original
# `‡∏≠‡∏≤‡∏Å‡∏≤‡∏®.py` script provided by the user.  This ensures the script
# produces both a multi‚Äëday forecast (via Open‚ÄëMeteo) and an
# immediate weather alert (via OpenWeather) within the same
# notification message.

# --- OpenWeather configuration ---
# If the user has set an environment variable named
# `OPENWEATHER_API_KEY`, it will be used to override the default key.
OPENWEATHER_API_KEY = os.environ.get(
    "OPENWEATHER_API_KEY", "c55ccdd65d09909976428698e8da16ec"
)

# --- TMD Data Sources (NEW) ---
# URL for TMD's radar page for the Chao Phraya basin. This page is
# monitored for near-real-time rain "nowcasting".
TMD_RADAR_URL = "https://weather.tmd.go.th/chaophraya.php"

def get_openweather_alert(
    lat: float | None = None,
    lon: float | None = None,
    api_key: str = OPENWEATHER_API_KEY,
    timezone: str = "Asia/Bangkok",
    timeout: int = 15,
) -> str:
    """
    Fetch a 5‚Äëday/3‚Äëhour forecast from OpenWeather and generate a
    succinct alert for today.  It summarises whether there will be
    exceptionally hot weather or a likelihood of rain/thunderstorms.
    If neither condition is met, it returns a generic message.  Any
    errors encountered will result in a descriptive error string.

    Parameters
    ----------
    lat : float
        Latitude of the location.
    lon : float
        Longitude of the location.
    api_key : str
        OpenWeather API key.  If not provided, a default key is used.
    timezone : str
        IANA timezone string for localising timestamps.
    timeout : int
        Timeout in seconds for the HTTP request.

    Returns
    -------
    str
        A message describing today's expected weather conditions.
    """
    try:
        # Use global coordinates if none are provided at call time.
        if lat is None:
            # Defer import to runtime to ensure WEATHER_LAT is defined.
            lat = WEATHER_LAT
        if lon is None:
            lon = WEATHER_LON
        # Build the OpenWeather API URL.  Using metric units to obtain
        # temperatures in Celsius directly.
        url = (
            f"https://api.openweathermap.org/data/2.5/forecast?lat={lat}&lon={lon}"
            f"&appid={api_key}&units=metric"
        )
        resp = requests.get(url, timeout=timeout)
        resp.raise_for_status()
        data = resp.json()
        # Establish local timezone and today's date string for filtering.
        tz = pytz.timezone(timezone)
        now = datetime.now(tz)
        today_str = now.strftime("%Y-%m-%d")
        max_temp = -999.0
        rain_detected_time: str | None = None
        # Iterate over forecast entries.  Each entry has a timestamp and
        # weather conditions.  We're only interested in entries for the
        # current local day.
        for entry in data.get("list", []):
            ts = entry.get("dt_txt", "")
            if today_str not in ts:
                continue
            temp = entry.get("main", {}).get("temp")
            weather = entry.get("weather", [])
            if temp is not None and isinstance(temp, (int, float)):
                if temp > max_temp:
                    max_temp = temp
            if weather:
                weather_id = weather[0].get("id")
                # Weather codes: thunderstorms (2xx) or heavy rain (5xx)
                if 200 <= weather_id < 300 or 500 <= weather_id < 600:
                    if not rain_detected_time:
                        # Extract HH:MM portion of the timestamp (YYYY‚ÄëMM‚ÄëDD HH:MM:SS)
                        rain_detected_time = ts[11:16] if len(ts) >= 16 else None
        # Construct messages based on conditions.
        messages = []
        if max_temp >= 35.0:
            messages.append(
                f"‚Ä¢ ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà ‡∏ï.‡πÇ‡∏û‡∏ô‡∏≤‡∏á‡∏î‡∏≥‡∏≠‡∏≠‡∏Å ‡∏≠‡∏∏‡∏ì‡∏´‡∏†‡∏π‡∏°‡∏¥‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì {round(max_temp, 1)}¬∞C"
            )
        if rain_detected_time:
            messages.append(
                f"‚Ä¢ ‡∏Ñ‡∏≤‡∏î‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏ù‡∏ô‡∏ï‡∏Å‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤ {rain_detected_time} ‡∏ô."
            )
        if not messages:
            messages.append("‚Ä¢ ‡∏™‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡∏õ‡∏Å‡∏ï‡∏¥ ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ù‡∏ô‡∏ï‡∏Å")
        return "\n".join(messages)
    except Exception as e:
        return f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏Å‡∏≤‡∏®: {e}"

def get_tmd_radar_nowcast(
    radar_url: str = TMD_RADAR_URL,
    target_area: str = "‡∏ä‡∏±‡∏¢‡∏ô‡∏≤‡∏ó"
) -> str | None:
    """
    Provides a short-term rain forecast (nowcast) by checking the TMD
    radar page for mentions of significant rain in a target area.

    Parameters
    ----------
    radar_url : str
        The URL to the TMD weather radar page.
    target_area : str
        The name of the province/area to check for (e.g., "‡∏ä‡∏±‡∏¢‡∏ô‡∏≤‡∏ó").

    Returns
    -------
    str | None
        A nowcast message if rain is imminent, otherwise None.
    """
    try:
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
        response = requests.get(radar_url, headers=headers, timeout=20)
        response.raise_for_status()
        response.encoding = 'utf-8'

        soup = BeautifulSoup(response.text, 'html.parser')
        page_text = soup.get_text()

        if target_area in page_text:
            if "‡∏ù‡∏ô‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á" in page_text or "‡∏ù‡∏ô‡∏´‡∏ô‡∏±‡∏Å" in page_text:
                return f"üõ∞Ô∏è ‡πÄ‡∏£‡∏î‡∏≤‡∏£‡πå‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ù‡∏ô‡∏ö‡∏£‡∏¥‡πÄ‡∏ß‡∏ì ‡∏à.{target_area} ‡∏≠‡∏≤‡∏à‡∏°‡∏µ‡∏ù‡∏ô‡∏ï‡∏Å‡πÉ‡∏ô 1-2 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á"
        return None
    except Exception as e:
        print(f"‚ùå ERROR: get_tmd_radar_nowcast: {e}")
        return None

# --- ‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏á‡∏ó‡∏µ‡πà ---
SINGBURI_URL = "https://singburi.thaiwater.net/wl"
DISCHARGE_URL = 'https://tiwrm.hii.or.th/DATA/REPORT/php/chart/chaopraya/small/chaopraya.php'
LINE_TOKEN = os.environ.get('LINE_CHANNEL_ACCESS_TOKEN')
LINE_API_URL = "https://api.line.me/v2/bot/message/broadcast"

# -- ‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å Excel --
THAI_MONTHS = {
    '‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°':1, '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå':2, '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°':3, '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô':4,
    '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°':5, '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô':6, '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°':7, '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°':8,
    '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô':9, '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°':10, '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô':11, '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°':12
}

# --- ‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡∏ì‡πå‡∏≠‡∏≤‡∏Å‡∏≤‡∏® ---
WEATHER_LAT = 15.120
WEATHER_LON = 100.283

def weather_code_to_description(code: int, precipitation: float) -> str:
    if code in {95, 96, 99}:
        return "‡∏û‡∏≤‡∏¢‡∏∏‡∏ù‡∏ô‡∏ü‡πâ‡∏≤‡∏Ñ‡∏∞‡∏ô‡∏≠‡∏á"
    if code == 0:
        return "‡∏ó‡πâ‡∏≠‡∏á‡∏ü‡πâ‡∏≤‡πÅ‡∏à‡πà‡∏°‡πÉ‡∏™"
    if code in {1, 2, 3}:
        return "‡∏°‡∏µ‡πÄ‡∏°‡∏Ü‡πÄ‡∏õ‡πá‡∏ô‡∏™‡πà‡∏ß‡∏ô‡πÉ‡∏´‡∏ç‡πà"
    if code in {45, 48}:
        return "‡∏°‡∏µ‡∏´‡∏°‡∏≠‡∏Å"
    if code in {51, 53, 55, 56, 57, 61, 63, 65, 66, 67, 80, 81, 82}:
        if precipitation >= 10.0:
            return "‡∏ù‡∏ô‡∏ï‡∏Å‡∏´‡∏ô‡∏±‡∏Å"
        if precipitation >= 2.0:
            return "‡∏ù‡∏ô‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á"
        return "‡∏ù‡∏ô‡∏ï‡∏Å‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢"
    if code in {71, 73, 75, 77, 85, 86}:
        return "‡∏´‡∏¥‡∏°‡∏∞"
    return "‡∏™‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö‡πÅ‡∏ô‡πà‡∏ä‡∏±‡∏î"

def get_weather_forecast(
    lat: float = WEATHER_LAT,
    lon: float = WEATHER_LON,
    days: int = 3,
    timezone: str = "Asia/Bangkok",
    timeout: int = 15,
) -> List[Tuple[str, str]]:
    try:
        params = {
            "latitude": lat,
            "longitude": lon,
            "daily": "weathercode,precipitation_sum",
            "timezone": timezone,
        }
        resp = requests.get(
            "https://api.open-meteo.com/v1/forecast",
            params=params,
            timeout=timeout,
        )
        resp.raise_for_status()
        data = resp.json().get("daily", {})
        dates = data.get("time", [])
        codes = data.get("weathercode", [])
        precipitation_list = data.get("precipitation_sum", [])
        forecast = []
        for i in range(min(days, len(dates))):
            date = dates[i]
            code = codes[i] if i < len(codes) else None
            prec = precipitation_list[i] if i < len(precipitation_list) else 0.0
            desc = weather_code_to_description(code, prec) if code is not None else "-"
            forecast.append((date, desc))
        return forecast
    except Exception as e:
        print(f"‚ùå ERROR: get_weather_forecast: {e}")
        return []

def get_historical_from_excel(year_be: int) -> int | None:
    path = f"data/‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ô‡πâ‡∏≥‡∏õ‡∏µ{year_be}.xlsx"
    try:
        if not os.path.exists(path):
            print(f"‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏µ‡πà: {path}")
            return None
        df = pd.read_excel(path)
        df = df.rename(columns={'‡∏õ‡∏£‡∏¥‡∏°‡∏≤‡∏ì‡∏ô‡πâ‡∏≥ (‡∏•‡∏ö.‡∏°./‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)': 'discharge'})
        df['month_num'] = df['‡πÄ‡∏î‡∏∑‡∏≠‡∏ô'].map(THAI_MONTHS)
        now = datetime.now(pytz.timezone('Asia/Bangkok'))
        today_d, today_m = now.day, now.month
        match = df[(df['‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà']==today_d) & (df['month_num']==today_m)]
        if not match.empty:
            print(f"‚úÖ ‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏µ {year_be}: {int(match.iloc[0]['discharge'])} ‡∏•‡∏ö.‡∏°./‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ")
            return int(match.iloc[0]['discharge'])
        else:
            print(f"‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà {today_d}/{today_m} ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏õ‡∏µ {year_be}")
            return None
    except Exception as e:
        print(f"‚ùå ERROR: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å Excel ‡πÑ‡∏î‡πâ ({path}): {e}")
        return None

def get_sapphaya_data(
    province_code: str = "18",
    target_tumbon: str = "‡πÇ‡∏û‡∏ô‡∏≤‡∏á‡∏î‡∏≥‡∏≠‡∏≠‡∏Å",
    target_station_name: str = "‡∏™‡∏£‡∏£‡∏û‡∏¢‡∏≤",
    timeout: int = 15,
    retries: int = 3,
):
    api_url_template = (
        "https://api-v3.thaiwater.net/api/v1/thaiwater30/public/waterlevel?province_code={code}"
    )
    for attempt in range(retries):
        try:
            url = api_url_template.format(code=province_code)
            headers = {
                "User-Agent": (
                    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                    "AppleWebKit/537.36 (KHTML, like Gecko) "
                    "Chrome/91.0.4472.124 Safari/537.36"
                ),
            }
            response = requests.get(url, headers=headers, timeout=timeout)
            response.raise_for_status()
            data = response.json().get("data", [])
            for item in data:
                geocode = item.get("geocode", {})
                tumbon_name = geocode.get("tumbon_name", {}).get("th", "")
                station_info = item.get("station", {})
                station_name = station_info.get("tele_station_name", {}).get("th", "")
                if tumbon_name == target_tumbon and station_name == target_station_name:
                    wl_str = item.get("waterlevel_msl")
                    water_level = None
                    if wl_str is not None:
                        try:
                            water_level = float(wl_str)
                        except ValueError:
                            water_level = None
                    bank_level = 13.87
                    print(
                        f"‚úÖ ‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏£‡∏£‡∏û‡∏¢‡∏≤: ‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ô‡πâ‡∏≥={water_level}, ‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ï‡∏•‡∏¥‡πà‡∏á={bank_level} (‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á)"
                    )
                    return water_level, bank_level
            print(
                f"‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ '{target_station_name}' ‡∏ó‡∏µ‡πà {target_tumbon} ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å API ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà {attempt + 1}"
            )
        except Exception as e:
            print(f"‚ùå ERROR: get_sapphaya_data (‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà {attempt + 1}): {e}")
        if attempt < retries - 1:
            time.sleep(3)
    return None, None

def fetch_chao_phraya_dam_discharge(url: str, timeout: int = 30):
    try:
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) '
                          'AppleWebKit/537.36 (KHTML, like Gecko) '
                          'Chrome/91.0.4472.124 Safari/537.36',
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
        }
        cache_buster_url = f"{url}?cb={random.randint(10000, 99999)}"
        response = requests.get(cache_buster_url, headers=headers, timeout=10)
        response.raise_for_status()
        response.encoding = 'utf-8'
        match = re.search(r'var json_data = (\[.*\]);', response.text)
        if not match:
            print("‚ùå ERROR: ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• JSON ‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö")
            return None
        json_string = match.group(1)
        data = json.loads(json_string)
        water_storage = data[0]['itc_water']['C13']['storage']
        if water_storage is not None:
            if isinstance(water_storage, (int, float)):
                value = float(water_storage)
            else:
                value = float(str(water_storage).replace(',', ''))
            print(f"‚úÖ ‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ç‡∏∑‡πà‡∏≠‡∏ô‡πÄ‡∏à‡πâ‡∏≤‡∏û‡∏£‡∏∞‡∏¢‡∏≤: {value}")
            return value
    except Exception as e:
        print(f"‚ùå ERROR: fetch_chao_phraya_dam_discharge: {e}")
    return None

def analyze_and_create_message(
    water_level: float,
    dam_discharge: float,
    bank_height: float,
    hist_2567: int | None = None,
    hist_2554: int | None = None,
    weather_summary: List[Tuple[str, str]] | None = None,
) -> str:
    distance_to_bank = bank_height - water_level
    if dam_discharge is not None and (dam_discharge > 2400 or distance_to_bank < 1.0):
        ICON = "üü•"
        HEADER = "‚ÄºÔ∏è ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏†‡∏±‡∏¢‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î ‚ÄºÔ∏è"
        summary_lines = [
            "‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥:",
            "1. ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏≠‡∏û‡∏¢‡∏û‡∏´‡∏≤‡∏Å‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á",
            "2. ‡∏Ç‡∏ô‡∏¢‡πâ‡∏≤‡∏¢‡∏ó‡∏£‡∏±‡∏û‡∏¢‡πå‡∏™‡∏¥‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏π‡∏á‡πÇ‡∏î‡∏¢‡∏î‡πà‡∏ß‡∏ô",
            "3. ‡∏á‡∏î‡πÉ‡∏ä‡πâ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏±‡∏ç‡∏à‡∏£‡∏£‡∏¥‡∏°‡πÅ‡∏°‡πà‡∏ô‡πâ‡∏≥",
        ]
    elif dam_discharge is not None and (dam_discharge > 1800 or distance_to_bank < 2.0):
        ICON = "üü®"
        HEADER = "‚ÄºÔ∏è ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡πÄ‡∏ù‡πâ‡∏≤‡∏£‡∏∞‡∏ß‡∏±‡∏á ‚ÄºÔ∏è"
        summary_lines = [
            "‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥:",
            "1. ‡∏ö‡πâ‡∏≤‡∏ô‡πÄ‡∏£‡∏∑‡∏≠‡∏ô‡∏£‡∏¥‡∏°‡∏ï‡∏•‡∏¥‡πà‡∏á‡∏ô‡∏≠‡∏Å‡∏Ñ‡∏±‡∏ô‡∏Å‡∏±‡πâ‡∏ô‡∏ô‡πâ‡∏≥ ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Ç‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏π‡∏á",
            "2. ‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏™‡∏ñ‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÉ‡∏Å‡∏•‡πâ‡∏ä‡∏¥‡∏î",
        ]
    else:
        ICON = "üü©"
        HEADER = "‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏Å‡∏ï‡∏¥"
        summary_lines = [
            f"‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ô‡πâ‡∏≥‡∏¢‡∏±‡∏á‡∏´‡πà‡∏≤‡∏á‡∏ï‡∏•‡∏¥‡πà‡∏á {distance_to_bank:.2f} ‡∏°. ‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤ \"‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢\" ‚úÖ",
            "‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô‡πÉ‡∏ä‡πâ‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï‡πÑ‡∏î‡πâ‡∏ï‡∏≤‡∏°‡∏õ‡∏Å‡∏ï‡∏¥‡∏Ñ‡∏£‡∏±‡∏ö",
        ]
    now = datetime.now(pytz.timezone("Asia/Bangkok"))
    TIMESTAMP = now.strftime("%d/%m/%Y %H:%M")
    msg_lines: List[str] = []
    msg_lines.append(f"{ICON} {HEADER}")
    msg_lines.append(f"üìç ‡∏ï.‡πÇ‡∏û‡∏ô‡∏≤‡∏á‡∏î‡∏≥‡∏≠‡∏≠‡∏Å ‡∏≠.‡∏™‡∏£‡∏£‡∏û‡∏¢‡∏≤ ‡∏à.‡∏ä‡∏±‡∏¢‡∏ô‡∏≤‡∏ó")
    msg_lines.append(f"üóìÔ∏è ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà: {TIMESTAMP} ‡∏ô.")
    msg_lines.append("")
    msg_lines.append("üåä ‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ô‡πâ‡∏≥ + ‡∏ï‡∏•‡∏¥‡πà‡∏á")
    msg_lines.append(f"‚Ä¢ ‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ô‡πâ‡∏≥: {water_level:.2f} ‡∏°.‡∏£‡∏ó‡∏Å.")
    msg_lines.append(f"‚Ä¢ ‡∏ï‡∏•‡∏¥‡πà‡∏á: {bank_height:.2f} ‡∏°.‡∏£‡∏ó‡∏Å. (‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤ {distance_to_bank:.2f} ‡∏°.)")
    msg_lines.append("")
    msg_lines.append("üíß ‡∏õ‡∏£‡∏¥‡∏°‡∏≤‡∏ì‡∏ô‡πâ‡∏≥‡∏õ‡∏•‡πà‡∏≠‡∏¢‡πÄ‡∏Ç‡∏∑‡πà‡∏≠‡∏ô‡πÄ‡∏à‡πâ‡∏≤‡∏û‡∏£‡∏∞‡∏¢‡∏≤")
    if dam_discharge is not None:
        msg_lines.append(f"{dam_discharge:,} ‡∏•‡∏ö.‡∏°./‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ")
    else:
        msg_lines.append("‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô")
    msg_lines.append("")
    msg_lines.append("üìä ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á")
    if hist_2567 is not None:
        msg_lines.append(f"‚Ä¢ ‡∏õ‡∏µ 2567: {hist_2567:,} ‡∏•‡∏ö.‡∏°./‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ")
    if hist_2554 is not None:
        msg_lines.append(f"‚Ä¢ ‡∏õ‡∏µ 2554: {hist_2554:,} ‡∏•‡∏ö.‡∏°./‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ")
    msg_lines.append("")
    msg_lines.append("üßæ ‡∏™‡∏£‡∏∏‡∏õ‡∏™‡∏ñ‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ì‡πå")
    for line in summary_lines:
        msg_lines.append(line)
    return "\n".join(msg_lines)

def create_error_message(station_status, discharge_status):
    now = datetime.now(pytz.timezone('Asia/Bangkok'))
    return (
        f"‚öôÔ∏è‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‚ùå‚öôÔ∏è\n"
        f"‡πÄ‡∏ß‡∏•‡∏≤: {now.strftime('%d/%m/%Y %H:%M')} ‡∏ô.\n\n"
        f"‚Ä¢ ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ô‡πâ‡∏≥‡∏™‡∏£‡∏£‡∏û‡∏¢‡∏≤: {station_status}\n"
        f"‚Ä¢ ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ç‡∏∑‡πà‡∏≠‡∏ô‡πÄ‡∏à‡πâ‡∏≤‡∏û‡∏£‡∏∞‡∏¢‡∏≤: {discharge_status}\n\n"
        f"‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Log ‡∏ö‡∏ô GitHub Actions ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Ñ‡∏£‡∏±‡∏ö"
    )

def send_line_broadcast(message):
    if not LINE_TOKEN:
        print("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö LINE_CHANNEL_ACCESS_TOKEN!")
        return
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {LINE_TOKEN}"
    }
    payload = {"messages": [{"type": "text", "text": message}]}
    try:
        res = requests.post(LINE_API_URL, headers=headers, json=payload, timeout=10)
        res.raise_for_status()
        print("‚úÖ ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° Broadcast ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!")
    except Exception as e:
        print(f"‚ùå ERROR: LINE Broadcast: {e}")

if __name__ == "__main__":
    print("=== ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ô‡πâ‡∏≥ (‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á) ===")
    
    # --- Fetch Core Data ---
    water_level, bank_level = get_sapphaya_data()
    dam_discharge = fetch_chao_phraya_dam_discharge(DISCHARGE_URL)
    hist_2567 = get_historical_from_excel(2567)
    hist_2554 = get_historical_from_excel(2554)

    # --- Build Core Message ---
    if water_level is not None and bank_level is not None and dam_discharge is not None:
        core_message = analyze_and_create_message(
            water_level,
            dam_discharge,
            bank_level,
            hist_2567,
            hist_2554,
        )
    else:
        station_status = "‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à" if water_level is not None else "‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß"
        discharge_status = "‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à" if dam_discharge is not None else "‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß"
        core_message = create_error_message(station_status, discharge_status)

    # --- Weather Section (Improved) ---
    print("\nüå¶Ô∏è  ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡∏ì‡πå‡∏≠‡∏≤‡∏Å‡∏≤‡∏®...")
    # 1. Get daily forecast from OpenWeather (for temp & general rain chance)
    weather_alert_daily = get_openweather_alert()

    # 2. Get short-term "nowcast" from TMD Radar
    radar_nowcast = get_tmd_radar_nowcast(target_area="‡∏ä‡∏±‡∏¢‡∏ô‡∏≤‡∏ó")

    # 3. Construct the final weather message section
    weather_section_lines = ["üå°Ô∏è ‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡∏ì‡πå‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ"]
    if radar_nowcast:
        # If radar detects imminent rain, prioritize that message
        weather_section_lines.append(radar_nowcast)
    
    if weather_alert_daily:
        # Append the daily summary from OpenWeather
        weather_section_lines.append(weather_alert_daily)
    
    if len(weather_section_lines) == 1:
        # Fallback if both weather sources fail
        weather_section_lines.append("‚Ä¢ ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡∏ì‡πå‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡πÑ‡∏î‡πâ")
    
    weather_section = "\n".join(weather_section_lines)

    # --- Assemble Final Message for LINE ---
    final_message = (
        f"{core_message}\n\n"
        f"{weather_section}\n\n"
        f"‡πÄ‡∏ó‡∏®‡∏ö‡∏≤‡∏•‡∏ï‡∏≥‡∏ö‡∏•‡πÇ‡∏û‡∏ô‡∏≤‡∏á‡∏î‡∏≥‡∏≠‡∏≠‡∏Å"
    )

    print("\nüì§ ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô:")
    print(final_message)
    print("\nüöÄ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏õ‡∏¢‡∏±‡∏á LINE...")
    send_line_broadcast(final_message)
    print("‚úÖ ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô")
